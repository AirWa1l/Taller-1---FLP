#lang eopl
;******************************************************************************************
; Autores : Juan Fernando Calle Sanchez - 2127464 ;
;           Michael Ramirez Suriel - 2122236 ;
;           Jose Adrian Marin Ordoñez - 2126988 ;

; Implementación de representación de sintáxis abstracta de un circuito ;

;******************************************************************************************
;; Interpretador para lenguaje que permite evaluar expresiones matemáticas y circuitos lógicos combinacionales

;; La definición BNF para las expresiones del lenguaje:
;;
;;  <program>     ::= <expression>
;;  <expression>  ::= <number>
;;                  ::= <identifier>
;;                  ::= <primitive> ({<expression>}*(,))
;;                  ::= if <expresion> then <expresion> else <expresion>
;;                  ::= let (identifier = expression)* in expression
;;                  ::=<circuit>
;;  <primitive>     ::= + | - | * | add1 | sub1
;;                  ::=eval-circuit | connect-ciruits | merge-circuits
;;  <circuit>       ::=<gate_list>
;;  <gate-list>     ::= empty | <gate> <gate-list>
;;  <gate>          ::= <identifier> <type> <input-list>)
;;  <type>          ::= and | or | not | xor
;;  <input-list>    ::= empty | <bool> <input-list> | <identifier> <input-list>
;;  <bool>          ::= True | False

;******************************************************************************************

;Especificación Léxica

(define scanner-spec-simple-interpreter
  '((white-sp
      (whitespace) skip)
     (comment
      ("%" (arbno (not #\newline))) skip)
     (identifier
      (letter (arbno (or letter digit "?"))) symbol)
     (number
      (digit (arbno digit)) number)
     (number
      ("-" digit (arbno digit)) number)))

;Especificación Sintáctica (gramática)** Extensión de la gramática para incluir circuitos y operaciones con circuitos
(define grammar-simple-interpreter
  '((program (expression) a-program)
     (expression (number) lit-exp)
     (expression (identifier) var-exp)
     (expression (primitive "(" (separated-list expression ",") ")") primapp-exp)
     (expression ("if" expression "then" expression "else" expression) if-exp)
     (expression ("let" (arbno identifier "=" expression) "in" expression) let-exp)
     (expression (circuit) circuit-exp)

     ; Primitivas
     (primitive ("+") add-prim)
     (primitive ("-") substract-prim)
     (primitive ("*") mult-prim)
     (primitive ("add1") incr-prim)
     (primitive ("sub1") decr-prim)
     (primitive ("eval-circuit") eval-circuit-prim)
     (primitive ("connect-circuits") connect-circuits-prim)
     (primitive ("merge-circuits") merge-circuits-prim)

     ; Circuitos
     (circuit ("(" "circuit" gate-list ")") a-circuit)
     (gate-list ("(" "gate_list" (arbno gate) ")") my-gate-list)
     (gate ("(" "gate" identifier gate-type input-list ")") a-gate)
     (gate-type ("and") and-type)
     (gate-type ("or") or-type)
     (gate-type ("not") not-type)
     (gate-type ("xor") xor-type)
     (input-list ("(" "input_list" (arbno input) ")") my-input-list)
     (input (boolean) bool-input)
     (input (identifier) ref-input)
     (boolean ("True") true-val)
     (boolean ("False") false-val)))

;Tipos de datos para la sintaxis abstracta de la gramática

(sllgen:make-define-datatypes scanner-spec-simple-interpreter grammar-simple-interpreter)

(define show-the-datatypes
  (lambda () (sllgen:list-define-datatypes scanner-spec-simple-interpreter grammar-simple-interpreter)))

;*******************************************************************************************
;Parser, Scanner, Interfaz

(define scan&parse
  (sllgen:make-string-parser scanner-spec-simple-interpreter grammar-simple-interpreter))

(define just-scan
  (sllgen:make-string-scanner scanner-spec-simple-interpreter grammar-simple-interpreter))

(define interpretador
  (sllgen:make-rep-loop  "--> "
    (lambda (pgm) (eval-program  pgm))
    (sllgen:make-stream-parser
      scanner-spec-simple-interpreter
      grammar-simple-interpreter)))

;*******************************************************************************************
;El Interprete

(define eval-program
  (lambda (pgm)
    (cases program pgm
      (a-program (body)
        (eval-expression body (init-env))))))

(define init-env
  (lambda ()
    (extend-env
      '(x y z True False)
      (list 4 2 5 
            (true-val)    ; En lugar de #t
            (false-val))  ; En lugar de #f
      (empty-env))))

(define eval-expression
  (lambda (exp env)
    (cases expression exp
      (lit-exp (datum) datum)
      (var-exp (id) (apply-env env id))
      (primapp-exp (prim rands)
        (let ((args (eval-rands rands env)))
          (apply-primitive prim args)))
      (if-exp (test-exp true-exp false-exp)
        (if (true-value? (eval-expression test-exp env))
            (eval-expression true-exp env)
            (eval-expression false-exp env)))
      (let-exp (ids rands body)
        (let ((args (eval-rands rands env)))
          (eval-expression body
            (extend-env ids args env))))
      (circuit-exp (circuit)
        (eval-circuit circuit env)))))

(define eval-rands
  (lambda (rands env)
    (map (lambda (x) (eval-rand x env)) rands)))

(define eval-rand
  (lambda (rand env)
    (eval-expression rand env)))

(define apply-primitive
  (lambda (prim args)
    (cases primitive prim
      (add-prim () (+ (car args) (cadr args)))
      (substract-prim () (- (car args) (cadr args)))
      (mult-prim () (* (car args) (cadr args)))
      (incr-prim () (+ (car args) 1))
      (decr-prim () (- (car args) 1))
      (eval-circuit-prim ()
        (if (not (= (length args) 1))
            (eopl:error 'apply-primitive "eval-circuit requiere exactamente 1 argumento, recibió ~s" args)
            (let ((circ (car args)))
              (if (circuit? circ)
                  (eval-circuit circ (empty-env))
                  (eopl:error 'apply-primitive "El argumento para eval-circuit debe ser un circuito")))))

      (connect-circuits-prim ()
        (if (not (= (length args) 2))
            (eopl:error 'apply-primitive "connect-circuits requiere exactamente 2 argumentos, recibió ~s" args)
            (let ((circ1 (car args))
                  (circ2 (cadr args)))
              (if (and (circuit? circ1) (circuit? circ2))
                  (connect-circuits circ1 circ2)
                  (eopl:error 'apply-primitive "Los argumentos para connect-circuits deben ser circuitos")))))

      (merge-circuits-prim ()
        (if (not (= (length args) 2))
            (eopl:error 'apply-primitive "merge-circuits requiere exactamente 2 argumentos, recibió ~s" args)
            (let ((circ1 (car args))
                  (circ2 (cadr args)))
              (if (and (circuit? circ1) (circuit? circ2))
                  (merge-circuits circ1 circ2)
                  (eopl:error 'apply-primitive "Los argumentos para merge-circuits deben ser circuitos"))))))))

(define true-value?
  (lambda (x)
    (not (or (zero? x) (eq? x #f)))))

(define last
  (lambda (lst)
    (if (null? (cdr lst))
        (car lst)
        (last (cdr lst)))))

;*******************************************************************************************
;Ambientes

(define-datatype environment environment?
  (empty-env-record)
  (extended-env-record
    (syms (list-of symbol?))
    (vals (list-of scheme-value?))
    (env environment?)))

(define scheme-value?
  (lambda (v)
    (or (number? v) (boolean? v) (circuit? v))))

(define empty-env
  (lambda ()
    (empty-env-record)))

(define extend-env
  (lambda (syms vals env)
    (extended-env-record syms vals env)))

(define apply-env
  (lambda (env sym)
    (cases environment env
      (empty-env-record ()
        (eopl:error 'apply-env "No binding for ~s" sym))
      (extended-env-record (syms vals env)
        (let ((pos (list-find-position sym syms)))
          (if (number? pos)
              (list-ref vals pos)
              (apply-env env sym)))))))

;****************************************************************************************
;Funciones Auxiliares



(define (get-gate-name g)
  (cases gate g
    (a-gate (name type inputs) name)))

(define (eval-circuit circuit-val env)
  (cases circuit circuit-val
    (a-circuit (gates)
      (eval-gate-list gates env))))

(define (eval-gate-list gates env)
  (cases gate-list gates
    (my-gate-list (gate-structs)
      (if (null? gate-structs)
          env
          (let* ((current-gate (car gate-structs))
                 (gate-result (eval-gate current-gate env))
                 (gate-name (cases gate current-gate
                             (a-gate (name type inputs) name)))
                 (new-env (extend-env (list gate-name)
                                     (list gate-result)
                                     env)))
            (eval-gate-list (my-gate-list (cdr gate-structs)) new-env))))))

(define (eval-gate g env)
  (cases gate g
    (a-gate (name type input-list)
      (let ((input-values (eval-input-list input-list env)))
        (apply-gate type input-values)))))

(define (eval-input-list input-list-val env)
  (cases input-list input-list-val
    (my-input-list (inputs)
      (map (lambda (inp)
             (cases input inp
               (bool-input (val)
                 (cases boolean val
                   (true-val () #t)
                   (false-val () #f)))
               (ref-input (name)
                 (apply-env env name))))
           inputs))))

(define apply-gate
  (lambda (type inputs)
    (cases gate-type type
      (and-type () (and (car inputs) (cadr inputs)))
      (or-type () (or (car inputs) (cadr inputs)))
      (not-type () (not (car inputs)))
      (xor-type () (xor (car inputs) (cadr inputs))))))

(define xor
  (lambda (a b)
    (and (or a b) (not (and a b)))))

(define type-of
  (lambda (g)
    (cases gate g
      (a-gate (name type inputs) type))))

(define gate-name
  (lambda (g)
    (cases gate g
      (a-gate (name type inputs) name))))

; 


(define connect-circuits
  (lambda (circ1 circ2)
    (cases circuit circ1
      (a-circuit (gates1)
        (cases circuit circ2
          (a-circuit (gates2)
            (let ((last-gate (last gates1)))
              (cases gate last-gate
                (a-gate (name type inputs)
                  (let ((output-name (string->symbol (string-append (symbol->string name) "-out"))))
                    (a-circuit
                      (append gates1
                              (list (a-gate output-name 
                                           type  ; Mantenemos el mismo tipo de compuerta
                                           (my-input-list (list (ref-input name)))))))))))))))))


(define merge-circuits
  (lambda (circ1 circ2 gate-type) ; Añadimos gate-type como argumento
    (cases circuit circ1
      (a-circuit (gates1)
        (cases circuit circ2
          (a-circuit (gates2)
            (let* ((last-gate1 (last gates1))
                   (last-gate2 (last gates2))
                   (new-gate-name (string->symbol "merged-gate"))
                   (new-gate (a-gate new-gate-name gate-type (my-input-list (list (ref-input (gate-name last-gate1)) (ref-input (gate-name last-gate2)))))))
              (a-circuit (append gates1 (append gates2 (list new-gate)))))))))))
(define list-find-position
  (lambda (sym los)
    (list-index (lambda (sym1) (eqv? sym1 sym)) los)))

(define list-index
  (lambda (pred ls)
    (cond
      ((null? ls) #f)
      ((pred (car ls)) 0)
      (else (let ((list-index-r (list-index pred (cdr ls))))
              (if (number? list-index-r)
                  (+ list-index-r 1)
                  #f))))))

;******************************************************************************************
;Pruebas

(show-the-datatypes)
just-scan
scan&parse
(just-scan "add1(x)")
(just-scan "add1(  x  )%cccc")
(just-scan "add1(  +(5, x)  )%cccc")
(just-scan "add1(  +(5, %ccccc x) ")
(scan&parse "add1(x)")
(scan&parse "add1(  x  )%cccc")
(scan&parse "add1(  +(5, x)  )%cccc")
(scan&parse "add1(  +(5, %cccc
x)) ")
(scan&parse "if -(x,4) then +(y,11) else *(y,10)")
(scan&parse "let
x = -(y,1)
in
let
x = +(x,2)
in
add1(x)")

(define caso1 (primapp-exp (incr-prim) (list (lit-exp 5))))
(define exp-numero (lit-exp 8))
(define exp-ident (var-exp 'c))
(define exp-app (primapp-exp (add-prim) (list exp-numero exp-ident)))
(define programa (a-program exp-app))
(define una-expresion-dificil (primapp-exp (mult-prim)
                                          (list (primapp-exp (incr-prim)
                                                            (list (var-exp 'v)
                                                                  (var-exp 'y)))
                                                (var-exp 'x)
                                                (lit-exp 200))))
(define un-programa-dificil
  (a-program una-expresion-dificil))

(interpretador)

; Debe retornar #f
